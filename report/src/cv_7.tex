\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}

\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
\usepackage{lipsum}

\usepackage{listings}
\usepackage{charter}
\usepackage{array}
\usepackage{here}

\newcolumntype{M}[1]{>{\raggedright}m{#1}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


%Listing Alloy
\lstdefinelanguage{alloy}{
  keywords={%
      assert, pred, all, no, lone, one, some, check, run,
      but, let, implies, not, iff, in, and, or, set, sig, Int, int,
      if, then, else, exactly, disj, fact, fun, module, abstract,
      extends, open, none, univ, iden, seq, enum
  },
  sensitive=true,  % case sensitive
  morecomment=[l]//,%
  morecomment=[l]{--},%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",
  numbers=none,
  firstnumber=1,
  aboveskip=3mm,
  belowskip=3mm,
  frame=single,
  showstringspaces=false,
  numberstyle=\tiny,
  stepnumber=2,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  basicstyle={\small\ttfamily},
  commentstyle=\itshape,
  columns=flexible,
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\bfseries,
}

% inline
\def\A{%
    \lstinline[language=alloy,basicstyle=\ttfamily,columns=fixed]}
 
% paragraph
\lstnewenvironment{alloy}[1][]{%
  \lstset{language=alloy,
    floatplacement={tbp},captionpos=b,
    xrightmargin=8pt,basicstyle=\ttfamily,#1}}{}

%Listing Alloy in tab
\lstdefinelanguage{alloyt}{
  keywords={%
      assert, pred, all, no, lone, one, some, check, run,
      but, let, implies, not, iff, in, and, or, set, sig, Int, int,
      if, then, else, exactly, disj, fact, fun, module, abstract,
      extends, open, none, univ, iden, seq, enum
  },
  sensitive=true,  % case sensitive
  morecomment=[l]//,%
  morecomment=[l]{--},%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",
  numbers=none,
  firstnumber=1,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  numberstyle=\tiny,
  stepnumber=2,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  basicstyle={\small\ttfamily},
  commentstyle=\itshape,
  columns=flexible,
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\bfseries,
}

% paragraph
\lstnewenvironment{alloyt}[1][]{%
  \lstset{language=alloyt,
    floatplacement={tbp},captionpos=b,
    xrightmargin=8pt,basicstyle=\ttfamily,#1}}{}
 

 
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

%\title{Génération et analyse automatisées d’ensembles de règles pour Picobot}
%\author{Quentin BAILLEUL \  Jérémy BOSSUT \  Romain PHILIPPON}


%\maketitle
\begin{titlepage}
\begin{center}

% Upper part of the page. The '~' is needed because \\
% only works if a paragraph has started.
\includegraphics[width=0.5\textwidth]{pictures/ul.png}~\\[1cm]

% Title
\HRule \\[0.2cm]
{ \huge \bfseries Génération et analyse automatisées d’ensembles de règles pour Picobot \\[0.4cm] }

\HRule \\[1.5cm]
Quentin BAILLEUL \  Jérémy BOSSUT \  Romain PHILIPPON

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\newpage
\tableofcontents

\newpage


\section{Introduction}
\href{https://learn.cs.uml.edu/ext/picobot/}{Picobot} est un projet utilisé comme support au cours introductoire d'informatique du Dr. Zachary Dodds au Harvey Mudd College de Californie. Ce programme modélise le comportement d’un robot-aspirateur dont le but est d’examiner tous les emplacements inoccupés de son environnement. Il est possible de programmer le robot en lui fournissant un ensemble de règles à respecter.
\\

Notre projet utilise le langage de spécification déclaratif Alloy pour générer ces règles. L'objectif est de chercher le plus petit ensemble de règles qui permet au robot de parcourir l’ensemble d’un niveau, quelque soit sa position initiale.
\\

La section suivante présente l’architecture du projet. Nous présentons le fonctionnement du programme Picobot en détails dans la section~\ref{sec:picobot} et les modèles Alloy utilisés dans la section ~\ref{sec:mod_alloy}. Les sections ~\ref{sec:result} et ~\ref{sec:ana_result} montrent respectivement les résultats obtenus et leur analyse. Enfin nous concluons notre travail dans la section ~\ref{sec:conclusion}.


\section{Picobot}
\label{sec:picobot}
Le robot Picobot se trouve dans un environnement rectangulaire modélisé par un tableau de cellules. Les cellules peuvent être inoccupées ou contenir un mur empêchant le passage du robot. Le robot est uniquement capable de percevoir l’occupation des cellules alentours. Comme il n’est pas doté de mémoire interne alors il ne peut pas savoir sur quelle cellule il se trouve et s’il l’a déjà parcouru. Il n’est donc pas possible d’utiliser un algorithme de recherche de chemins tel que \href{http://fr.wikipedia.org/wiki/Recherche_de_chemin}{Dijkstra ou A*}.

Pour se déplacer, le robot respecte un ensemble de règles pré-établies. Une règle est formée de la façon suivante:
\textit{CurrentState Surroundings} -> \textit{MovementDirection NewState}

\textit{CurrentState} et \textit{NewState} sont deux nombres entiers compris entre 0 et 99. Ces nombres représentent le numéro de l’état dans lequel se trouve le robot respectivement avant et après l’exécution de la règle. Au lancement du programme, le robot se trouve dans l’état 0.

\textit{Surroundings} est une chaîne de quatre caractères représentant l’occupation des cellules voisines. Les environnement possibles sont les suivants : 


\begin{figure}[H]
\centering{
\includegraphics[scale=0.3]{pictures/Image0.png}}
\end{figure}

Il est possible de remplacer un des caractères par ‘*’. Le caractère ‘*’ signifie qu’on ne se soucie pas de la présence ou non d’un obstacle à l’emplacement désigné.

\textit{MovementDirection} représente la direction dans laquelle on souhaite que le robot se déplace. Le robot peut se déplacer dans les quatre directions cardinales (N pour Nord, E pour Est, W pour Ouest, S pour Sud) ou choisir de ne pas bouger (X).
\newline

\textbf{Exemple} : Considérons l’ensemble de règles pour Picobot suivant.\\
\begin{center}
0 x*** -> N 0\\
0 N*** -> W 1\\
1 ***x -> S 1\\
1 ***S -> X 0
\end{center}

% \begin{figure}[H]
% \centering{
% \includegraphics[scale=1]{pictures/Image1.png}
% }
% \end{figure}

La règle \textit{0 x*** -> N 0} est suivie lorsque le robot est dans l'état 0 et qu'il détecte une cellule libre au Nord. Lorsque cette situation se produit, le robot se déplace d'une unité vers le Nord et reste à l'état 0. Lorsque le robot rencontre un obstacle au Nord, la règle \textit{0 N*** -> W 1} change son état à 1 et le fait se déplacer vers l’Ouest. Une fois le robot dans l'état 1, il suit la règle règle \textit{1 ***x -> S 1} et va se déplacer vers le Sud jusqu'à ce qu'il rencontre un mur dans cette direction. Dans ce cas, il revient à l'état 0 selon la règle \textit{1 ***S -> X 0}.

\section{Modèles Alloy}
\label{sec:mod_alloy}
Le caractère ‘*’ a été introduit dans le but d’obtenir une représentation plus succincte des règles. Pour tout ensemble de règles qui utilise ce caractère, il est alors possible de trouver un ensemble de règles équivalent qui ne l’utilise pas.
%[Image Règles]

\begin{figure}[H]
\centering{\includegraphics[scale=0.7]{pictures/Image2.png}}
\end{figure}


Dans cette section, nous présentons deux modèles Alloy - le premier sans ‘*’ et le second avec - qui permettent de générer des ensembles de règles pour Picobot.

\subsection{Modèle original}
\subsubsection{Ensembles}
Le modèle comprend trois signatures et deux énumérations :
\\

\begin{tabular}{|M{5cm}|M{8cm}|}
    \hline
    \textbf{Ensemble} & \textbf{Description} \tabularnewline
    \hline
    \centering{
    \begin{alloyt}
 sig Rule {
  current_state: Int,
  env: Surroundings,
  next: Action
}
\end{alloyt}}& \textbf{Rule} définit une règle applicable où \textit{current\_state} désigne l'état initial du robot, \textit{env} son environnement actuel et \textit{next} l'action à effectuer \tabularnewline
    \hline
    \centering{\begin{alloyt}
sig Surroundings {
  north: Wall,
  east: Wall,
  west: Wall,
  south: Wall
}
\end{alloyt}} & \textbf{Surroundings} définit un environnement en indiquant la présence ou non d'un mur dans chacun des quatre points cardinaux.
\tabularnewline
    \hline
    \centering{\begin{alloyt}
 sig Action {
  next_state: Int,
  move: Move
}
\end{alloyt}} & \textbf{Action} définit une action à effectuer où \textit{next\_state} désigne le nouvel état du robot et \textit{move} le déplacement à effectuer\tabularnewline
    \hline
    \centering{\begin{alloyt}
enum Move {N, E, W, S, X}
\end{alloyt}} & \textbf{Move} définit les cinq mouvements possibles par le robot: un pour chaque direction cardinale (N,E,W,S) et X pour désigner l’absence de mouvement.
\tabularnewline
    \hline
    \centering{\begin{alloyt}
 enum Wall {True, False}
\end{alloyt}} & \textbf{Wall} est identique à l’ensemble des booléens et définit l’état d’un mur (présent: True, absent: False)\tabularnewline
    \hline

 \end{tabular}

\subsubsection{Faits}
Afin de garantir la compatibilité des règles générées avec le programme Picobot, six faits sont utilisés : 


\subsubsection*{Numéro d’état valide}
 Le programme Picobot ne gère que 100 numéros d’état numérotés de 0 à 99 :

\begin{alloy}
fact validState {
  all r:Rule | r.current_state >= 0 && r.current_state < 100
  all a:Action | a.next_state >= 0 && a.next_state < 100
}
\end{alloy}

\subsubsection*{État initial}
Le robot débutant à l’état 0, il est nécessaire qu'il existe au moins une règle commençant par cet état. De plus, cette règle doit exécuter une action avec un mouvement effectif dans l'une des quatre directions :

\begin{alloy}
fact initialState {
  some r:Rule | r.current_state = 0 && r.next.move != X
}
\end{alloy}

\subsubsection*{Déterminisme du comportement}

Le comportement du robot doit être déterministe. Il ne peut donc pas y avoir d'ambiguïté sur le choix de la règle à appliquer dans une situation donnée. Autrement dit, deux règles ayant le même numéro d'état et le même environnement ne peuvent pas coexister. 

\begin{alloy}
fact noDuplicatedRule {
  all r1: Rule | all r2:Rule-r1 | r1.current_state = r2.current_state => r1.env != r2.env 
}
\end{alloy}

En conséquence, il ne peut pas exister non plus deux instances Surroundings en Alloy qui représente le même environnement.

\begin{alloy}
fact noDuplicatedSurroundings {
  all s1:Surroundings | no s2:Surroundings-s1 | s1.north = s2.north && s1.east = s2.east && s1.west = s2.west && s1.south = s2.south  
}
\end{alloy}

\newpage
\subsubsection*{Enchaînement des règles}
Pour empêcher les règles isolées, il est nécessaire que chaque action emmène vers un état pour lequel il existe une règle.

\begin{alloy}
fact consistentStateNumbers {
  all a:Action | some r:Rule | a.next_state = r.current_state 
}
\end{alloy}

On s’assure également que chaque action dépend d’une règle pour ne pas avoir d’actions inutilisées qui influent sur le fait précédent.

\begin{alloy}
fact allActionsHaveRule {
  all a:Action | some r:Rule | r.next = a
}
\end{alloy}

\subsubsection{Prédicats d’optimisation}
Quatre prédicats sont ajoutés pour générer un meilleur ensemble de règles. Les modifications induites par ces prédicats ne sont pas nécessaires au bon fonctionnement de Picobot mais permettent d'éviter de générer des règles qui ne peuvent pas être appelées ou qui n'apportent aucune plus-value à l'ensemble.

\subsubsection*{Immobilisme}
Une règle qui conserve l’état et n'exécute pas de mouvement bloquerait le robot dans une boucle infinie. Le prédicat suivant permet d'empêcher la génération de ce type de règles.

\begin{alloy}
pred neverHoldStill {
  all r:Rule | r.next.move = X => r.next.next_state != r.current_state
}
\end{alloy}
Puisque le robot ne peut pas se retrouver dans une situation où il est encerclé de murs, il n'est pas nécessaire de générer un Surroundings où les quatre directions sont bloquantes.
\begin{alloy}
pred neverStucked {
  no s:Surroundings | s.north = True && s.east = True && s.west = True && s.south = True
}
\end{alloy}

\newpage

Il n'est pas pertinent de demander au robot de se déplacer dans une direction lorsque l'on sait au préalable qu'elle contient un mur. 

\begin{alloy}
pred noMoveIntoAWall {
  all r:Rule | r.env.north = True => r.next.move != N
  all r:Rule | r.env.east = True => r.next.move != E
  all r:Rule | r.env.west = True => r.next.move != W
  all r:Rule | r.env.south = True => r.next.move != S
}
\end{alloy}

\subsubsection*{Règles inatteignables}
Pour qu’une règle soit atteignable, il faut que son état initial soit accessible depuis une autre règle. Il faut donc, pour chaque règle dont l’état initial \textit{state} est différent de 0, qu’il existe une règle dont l’état initial est différent de \textit{state} qui exécute une action amenant à l’état \textit{state}. Il est important de noter que cette condition est nécessaire mais pas suffisante. Par exemple, dans un ensemble de trois règles dont les transformations d’état sont R1: 0 -> 0, R2: 1->2 et R3: 2->1, le prédicat est respecté mais les règles R2 et R3 sont inatteignables.

\begin{alloy}
pred preventInaccessibleRule {
  all r1:Rule | some r2:Rule | r1.current_state != 0 => r1.current_state != r2.current_state && 2.next.next_state = r1.current_state
}
\end{alloy}

\subsubsection{Autres prédicats}
Le modèle comprend également quelques prédicats dont les apports sont essentiellement cosmétiques. Ceux-ci permettent l'utilisation de numéros d’états consécutifs, d'empêcher la génération de deux actions identiques ou d’environnements non utilisés. Ces prédicats n'ayant pas d'influence sur l'ensemble de règles généré, ils sont inactifs par défaut afin d'améliorer les performances d'Alloy.

\subsection{Modèle alternatif}
Le modèle alternatif autorise l'autorisation du caractère ‘*’ pour décrire un environnement. Pour réaliser cette modification, un troisième état est ajouté dans l’énumération \textit{\textbf{Wall}} :

\begin{alloy}
enum Wall {True, False, Star}
\end{alloy}

La mise en place du caractère ‘*’ impose également la création d'un nouveau fait pour garder l'aspect déterministe des ensembles de règles :

\begin{alloy}
fact compatibleRules {
  all r1: Rule | no r2:Rule-r1 | 
  (r1.current_state = r2.current_state) &&
  (r1.env.north = r2.env.north || r1.env.north = Star || r2.env.north = Star) &&
  (r1.env.east = r2.env.east || r1.env.east = Star || r2.env.east = Star) &&
  (r1.env.west = r2.env.west|| r1.env.west = Star || r2.env.west = Star) &&
  (r1.env.south = r2.env.south || r1.env.south = Star || r2.env.south = Star) 
}
\end{alloy}

\subsection{Comparaison des modèles}
\begin{tabular}{|M{6cm}|M{6cm}|}
    \hline
    \textbf{Modèle original} & \textbf{Modèle alternatif} \tabularnewline
    \hline
    Augmente grandement le nombre de règles nécessaires à la réalisation d'un niveau de Picobot & Permet l'utilisation d'une écriture réduite des règles. \tabularnewline
    \hline
    Limite le nombre d'objets Surroundings possibles à $2^4-1=15$ & Augmente le nombre d'objets Surroundings possibles à $3^4-1=80$
 \tabularnewline
    \hline
    Pour 25 instances d'objets, Alloy réduit le problème à :
159374 variables, dont 4350 primaires et 429710 clauses & Pour 25 instances d’objets, Alloy réduit le problème à :
181326 variables, dont 4450 primaires et 480863 clauses. \tabularnewline
    \hline
    \end{tabular}

\section{Résultats}
\label{sec:result}
\section{Analyse des résultats}
\label{sec:ana_result}
\section{Conclusion}
\label{sec:conclusion}

\end{document}
